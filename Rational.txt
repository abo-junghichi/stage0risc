# PC相対アドレスの基点
メモリ上のオブジェクトのうち少なくともコードは、
そのオブジェクトの先頭アドレスにより参照される。
データにはそのような制限は本来存在しないが、コードと同じように扱えば、
プリフェッチ機構などをコードと共有化した実装が可能。
当命令セットでは、load,store命令のdisplacementから符号拡張を省いている。
なので、PC相対アドレスの基点は先頭に近い方が有利。

アドレスフィールドが基点と隣接していて、
かつ、アドレスがフィールド幅に収まれば、
命令内のフィールドレイアウトを気にせずにアドレス計算可能。
*命令レイアウトが複雑
*全アドレス空間に対応できるまで、アドレスフィールド幅を拡張できる
*命令長決定などにより、命令先頭にアドレスフィールドを置けない
x86のような可変長命令では、命令の最後尾が相対アドレスの基点として有利。
実際、x86は命令最後尾=次命令を相対アドレスの基点にしている。

しかし、当命令セットはレイアウトが単純なので、
命令レイアウトを考慮しても計算が複雑にならない。
フィールドはアドレス空間より狭い幅に固定されているので、
フィールドに収まらない大きさの相対アドレスの場合は、
複数命令列を扱うため命令レイアウトを考慮しなければならない。
なのでRISC-Vと同様に、当命令セットでは命令先頭を相対アドレスの基点にしている。

# デバイスモデル
パンチカードシステム or タビュレーティングマシンが、
人力のみで構成可能なコンピュータストレージの限界に近い。
また、Unixの標準入出力またはファイル二つのみでエミュレートでき、
仮想マシンを構成しやすい。

# 命令設計
アセンブラの主要機能であるアドレス計算が楽になるよう、
相対アドレッシングモードは一種類のみ。
逆アセンブルの一意性やダンプファイルの目視を楽にするため、
メモリ境界に命令長を合わせる。
現在流通しているファイル編集ツールに合わせ、バイト単位のメモリモデルを選択。

(1,2,4,8,16byteなどの)可変長命令なので、
命令長決定のために命令先頭にオペコードが必要。
シフト演算より安いビットマスク演算で命令長決定を行うため、
リトルエンディアンのメモリモデルとなる。
仮想マシンの性能から、フィールド幅はバイト単位でゼロレジスタは排除。
ハードウェアでの構築のし易さと性能のバランスから、
RISC-VやMIPSのような3オペランドRISCを選択。
フィールド幅がバイトなので、256個ものレジスタを持つ32bit長命令となる。
Lua 5.0インタプリタと同様に即値フィールドを持つ演算命令を削減。
演算命令の即値の殆どは、ソースプログラムに直接かかれた値なので、
その個数はプログラマーの人力により制限され、
豊富なレジスタでキャッシュできる。
逆に、飛び先アドレスはコンパイラで自動生成され、
殆ど加工されずに使われるので、分岐命令については別。
出力レジスタとオペコードのため、即値フィールドは2バイトが限界。
アセンブル時の負担である
バイトオーダ変換やメモリ境界ミスを避けるため、
命令内の2バイト境界にリトルエンディアンのまま配置。
即値デコードでのマルチプレクサを減らすため、
メモリアクセス命令でのdisplacementフィールドは、
2バイト即値フィールドの下位バイトを使う。
この時点で、store命令の二つの入力レジスタの位置が定まる。
上記アドレッシングモードの単純化のため、
条件分岐命令のフラグ入力レジスタが
即値設定命令の出力レジスタと同じフィールドになり、
アウトオブオーダープロセッサのために
出力レジスタの位置まで固定するのは不可能になる。

比較演算命令があるので、
条件分岐命令からは比較演算機能を省き、命令種類を減らす。
MIPS Release 6に倣い、比較演算命令の返り値は(0,1)ではなく(0,~0(=-1))にする。
(0,~0)を(0,1)に変換するのはビットマスクでも可能だが、
その逆は加算器のcarry-borrowが必要で、ビット演算より回路のレイテンシが長い。

命令長とメモリモデルの制限により、
メモリアクセス命令はdouble wordからbyteまで備える。
バイト単位のメモリインターリーブを最大アクセス幅分、
または、最大アクセス幅単位のメモリインターリーブを2列使うことで、
メモリ境界に制限する場合と同等ステージ数のパイプライン構成は可能。
しかし、汎用性能よりもメモリダンプの検証や実装の単純さを優先するため、
アクセス単位はメモリ境界に制限する。

# TODO
## アセンブラ規約
パンチカードシステムを前提とするなら、
ビット1=穴を開ける手間の少ないレジスタを優先的に使うべき。
以下は現状の備忘録であって、理想ではない。

%ff
捨てレジスタ。
長い即値の生成はレジスタ一つで足りる。
ジャンプ&リンク命令のリンクを捨てるのにも使う。
%fe = 16
即値の上位ビットのためのシフト量。
%fd =  8
displacementの上位ビットのためのシフト量。
%fc
PC相対レジスタ。
スタックなどベースアドレスは最初から汎用レジスタにあるので、
長い即値との計算に使えるが、
PCの場合は即値とは別のレジスタに一旦格納しなければならない。
