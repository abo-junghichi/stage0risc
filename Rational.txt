# PC相対アドレスの基点
メモリ上のオブジェクトのうち少なくともコードは、
そのオブジェクトの先頭アドレスにより参照される。
データにはそのような制限は本来存在しないが、コードと同じように扱えば、
プリフェッチ機構などをコードと共有化した実装が可能。
当命令セットでは、load,store命令のdisplacementから符号拡張を省いている。
なので、PC相対アドレスの基点は先頭に近い方が有利。

アドレスフィールドが基点と隣接していて、
かつ、アドレスがフィールド幅に収まれば、
命令内のフィールドレイアウトを気にせずにアドレス計算可能。
*命令レイアウトが複雑
*全アドレス空間に対応できるまで、アドレスフィールド幅を拡張できる
*命令長決定などにより、命令先頭にアドレスフィールドを置けない
x86のような可変長命令では、命令の最後尾が相対アドレスの基点として有利。
実際、x86は命令最後尾=次命令を相対アドレスの基点にしている。

しかし、当命令セットはレイアウトが単純なので、
命令レイアウトを考慮しても計算が複雑にならない。
フィールドはアドレス空間より狭い幅に固定されているので、
フィールドに収まらない大きさの相対アドレスの場合は、
複数命令列を扱うため命令レイアウトを考慮しなければならない。
なのでRISC-Vと同様に、当命令セットでは命令先頭を相対アドレスの基点にしている。

# デバイスモデル
パンチカードシステム or タビュレーティングマシンが、
人力のみで構成可能なコンピュータストレージの限界に近い。
また、Unixの標準入出力またはファイル二つのみでエミュレートでき、
仮想マシンを構成しやすい。

# 命令設計
アセンブラの主要機能であるアドレス計算が楽になるよう、
相対アドレッシングモードは一種類のみ。
逆アセンブルの一意性やダンプファイルの目視を楽にするため、
メモリ境界に命令長を合わせる。
現在流通しているファイル編集ツールに合わせ、8ビット単位のメモリモデルを選択。

(1,2,4,8,16byteなどの)可変長命令なので、
命令長決定のために命令先頭にオペコードが必要。
シフト演算より安いビットマスク演算で命令長決定を行うため、
リトルエンディアンのメモリモデルとなる。
仮想マシンの性能から、フィールド幅はバイト単位でゼロレジスタは排除。
ハードウェアでの構築のし易さと性能のバランスから、
RISC-VやMIPSのような3オペランドRISCを選択。
フィールド幅がバイトなので、256個ものレジスタを持つ32bit長命令となる。
Lua 5.0インタプリタと同様に即値フィールドを持つ演算命令を削減。
演算命令の即値の殆どは、ソースプログラムに直接かかれた値なので、
その個数はプログラマーの人力により制限され、
豊富なレジスタでキャッシュできる。
逆に、飛び先アドレスはコンパイラで自動生成され、
殆ど加工されずに使われるので、分岐命令については別。
出力レジスタとオペコードのため、即値フィールドは2バイトが限界。
アセンブル時の負担である
バイトオーダ変換やメモリ境界ミスを避けるため、
命令内の2バイト境界にリトルエンディアンのまま配置。
レジスタの入力ポート数の制限のため、store命令のメモリアドレッシングは
入力レジスタ1個とdisplacement即値の和を採用。
演算命令と違い、負数のdisplacementはあまり使わないので、
即値デコードでのマルチプレクサを減らすことを優先し、
displacementフィールドは、2バイト即値フィールドの下位バイトを使い、
符号ビットの位置を固定するためゼロ拡張を行う。
レジスタ間演算命令でも即値フィールドを設けるなら、
2バイト即値フィールドの上位バイトを使う方が、
命令レイアウトの種類を抑えられる。
この時点で、二つの入力レジスタの位置が定まる。
また、条件分岐命令のフラグ入力レジスタが
即値設定命令の出力レジスタと同じフィールドになり、
アウトオブオーダープロセッサのために
出力レジスタの位置まで固定するのは不可能になる。
なので、メモリアドレッシングレイアウトをload命令とstore命令で揃える。

比較演算命令があるので、
条件分岐命令からは比較演算機能を省き、命令種類を減らす。
MIPS Release 6に倣い、比較演算命令の返り値は(0,1)ではなく(0,~0(=-1))にする。
(0,~0)を(0,1)に変換するのはビットマスクでも可能だが、
その逆は加算器のcarry-borrowが必要で、ビット演算より回路のレイテンシが長い。

値が既知のレジスタを条件分岐命令の入力に使うことで、即値ジャンプが可能。
しかし、分岐判定処理はインタプリタの負担が大きいので、即値ジャンプ命令は残す。
フィールドが一つ空いているので、リンクレジスタ指定に使う。

RISC-Vに倣い、2バイト即値フィールドの値は符号拡張され、
即値フィールドに収まらない値を合成する時は、
ゼロ拡張されるMIPSと異なり、論理和ではなく加算が使われる。
また、位置独立コードでは、
ジャンプ命令の扱う飛び先アドレスの即値には相対アドレッシングが用いられ、
相対アドレスから絶対アドレスへの変換には加算が必要。
なので、レジスタ間接ジャンプ&リンクでは、
入力レジスタ二つを加算したアドレスをジャンプ先とし、
フィールド三つを使い切る。
そうではなく、メモリアクセス命令と同じアドレッシングモードの場合、
即値が使えるが、その幅は1バイト。
アドレス幅は32ビットと16ビットの倍数なので、
絶対アドレスの指定に必要な即値設定命令の数を減らせない。
ちなみに、レジスタ長を32bitより大きくした場合、
64bit版RISC-Vで即値を生成するときの罠 - よーる
https://lpha-z.hatenablog.com/entry/2020/01/12/231500
で詳説されているように、即値生成に加算を用いる方法には問題が生じるので、
相対アドレスでなければgccのようにxorを用いる方が望ましい。

命令長とメモリモデルの制限により、
メモリアクセス命令はdouble wordからbyteまで備える。
読み出すメモリ幅がレジスタより狭い場合は符号拡張で上位ビットを補い、
多くのISAで用意されている、ゼロで上位ビットを拡張するものは省く。
符号拡張からゼロ拡張への変換はビットマスクの1命令で済むがその逆は、
「符号ビットへ加算後、符号ビットを反転」で2命令必要。
バイト単位のメモリインターリーブを最大アクセス幅分、
または、最大アクセス幅単位のメモリインターリーブを2列使うことで、
メモリ境界に制限する場合と同等ステージ数のパイプライン構成は可能。
しかし、汎用性能よりもメモリダンプの検証や実装の単純さを優先するため、
アクセス単位はメモリ境界に制限する。

ビットシフト演算は、Javaや.NETやECMAscriptやRISC-Vに倣い、
最低でも1ビットは被演算数由来の値を残すため、
そして、シフト回路の実装を易しくするため、
「レジスタサイズ-1」のビットマスクを演算数にかけてから、シフトを行う。
論理シフトによる符号拡張のエミュレートでは
shrl a,b,r; shrl 1000,b,m; xor r,m,r; sub r,m,r
の4命令、算術シフトでゼロ拡張をエミュレートする場合も
xor a,1000,r; shra r,b,r; shra 1000,b,m; sub r, m, r
4命令かかるので、slt,sltuと同様に符号拡張とゼロ拡張の両方を実装する。

# TODO
## アセンブラ規約
パンチカードシステムを前提とするなら、
ビット1=穴を開ける手間の少ないレジスタを優先的に使うべき。
以下は現状の備忘録であって、理想ではない。

%ff
捨てレジスタ。
長い即値の生成はレジスタ一つで足りる。
ジャンプ&リンク命令のリンクを捨てるのにも使う。
%fe = 16
即値の上位ビットのためのシフト量。
%fd =  8
displacementの上位ビットのためのシフト量。
%fc
PC相対レジスタ。
スタックなどベースアドレスは最初から汎用レジスタにあるので、
長い即値との計算に使えるが、
PCの場合は即値とは別のレジスタに一旦格納しなければならない。
